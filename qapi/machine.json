# -*- Mode: Python -*-
#
# This work is licensed under the terms of the GNU GPL, version 2 or later.
# See the COPYING file in the top-level directory.

##
# = Machines
##

##
# @SysEmuTarget:
#
# The comprehensive enumeration of QEMU system emulation ("softmmu")
# targets. Run "./configure --help" in the project root directory, and
# look for the *-softmmu targets near the "--target-list" option. The
# individual target constants are not documented here, for the time
# being.
#
# Notes: The resulting QMP strings can be appended to the "qemu-system-"
#        prefix to produce the corresponding QEMU executable name. This
#        is true even for "qemu-system-x86_64".
#
# Since: 3.0
##
{ 'enum' : 'SysEmuTarget',
  'data' : [ 'aarch64', 'alpha', 'arm', 'cris', 'hppa', 'i386', 'lm32',
             'm68k', 'microblaze', 'microblazeel', 'mips', 'mips64',
             'mips64el', 'mipsel', 'moxie', 'nios2', 'or1k', 'ppc',
             'ppc64', 'riscv32', 'riscv64', 's390x', 'sh4',
             'sh4eb', 'sparc', 'sparc64', 'tricore', 'unicore32',
             'x86_64', 'xtensa', 'xtensaeb' ] }

##
# @CpuInfoArch:
#
# An enumeration of cpu types that enable additional information during
# @query-cpus and @query-cpus-fast.
#
# @s390: since 2.12
#
# @riscv: since 2.12
#
# Since: 2.6
##
{ 'enum': 'CpuInfoArch',
  'data': ['x86', 'sparc', 'ppc', 'mips', 'tricore', 's390', 'riscv', 'other' ] }

##
# @CpuInfo:
#
# Information about a virtual CPU
#
# @CPU: the index of the virtual CPU
#
# @current: this only exists for backwards compatibility and should be ignored
#
# @halted: true if the virtual CPU is in the halt state.  Halt usually refers
#          to a processor specific low power mode.
#
# @qom_path: path to the CPU object in the QOM tree (since 2.4)
#
# @thread_id: ID of the underlying host thread
#
# @props: properties describing to which node/socket/core/thread
#         virtual CPU belongs to, provided if supported by board (since 2.10)
#
# @arch: architecture of the cpu, which determines which additional fields
#        will be listed (since 2.6)
#
# Since: 0.14.0
#
# Notes: @halted is a transient state that changes frequently.  By the time the
#        data is sent to the client, the guest may no longer be halted.
##
{ 'union': 'CpuInfo',
  'base': {'CPU': 'int', 'current': 'bool', 'halted': 'bool',
           'qom_path': 'str', 'thread_id': 'int',
           '*props': 'CpuInstanceProperties', 'arch': 'CpuInfoArch' },
  'discriminator': 'arch',
  'data': { 'x86': 'CpuInfoX86',
            'sparc': 'CpuInfoSPARC',
            'ppc': 'CpuInfoPPC',
            'mips': 'CpuInfoMIPS',
            'tricore': 'CpuInfoTricore',
            's390': 'CpuInfoS390',
            'riscv': 'CpuInfoRISCV' } }

##
# @CpuInfoX86:
#
# Additional information about a virtual i386 or x86_64 CPU
#
# @pc: the 64-bit instruction pointer
#
# Since: 2.6
##
{ 'struct': 'CpuInfoX86', 'data': { 'pc': 'int' } }

##
# @CpuInfoSPARC:
#
# Additional information about a virtual SPARC CPU
#
# @pc: the PC component of the instruction pointer
#
# @npc: the NPC component of the instruction pointer
#
# Since: 2.6
##
{ 'struct': 'CpuInfoSPARC', 'data': { 'pc': 'int', 'npc': 'int' } }

##
# @CpuInfoPPC:
#
# Additional information about a virtual PPC CPU
#
# @nip: the instruction pointer
#
# Since: 2.6
##
{ 'struct': 'CpuInfoPPC', 'data': { 'nip': 'int' } }

##
# @CpuInfoMIPS:
#
# Additional information about a virtual MIPS CPU
#
# @PC: the instruction pointer
#
# Since: 2.6
##
{ 'struct': 'CpuInfoMIPS', 'data': { 'PC': 'int' } }

##
# @CpuInfoTricore:
#
# Additional information about a virtual Tricore CPU
#
# @PC: the instruction pointer
#
# Since: 2.6
##
{ 'struct': 'CpuInfoTricore', 'data': { 'PC': 'int' } }

##
# @CpuInfoRISCV:
#
# Additional information about a virtual RISCV CPU
#
# @pc: the instruction pointer
#
# Since 2.12
##
{ 'struct': 'CpuInfoRISCV', 'data': { 'pc': 'int' } }

##
# @CpuS390State:
#
# An enumeration of cpu states that can be assumed by a virtual
# S390 CPU
#
# Since: 2.12
##
{ 'enum': 'CpuS390State',
  'prefix': 'S390_CPU_STATE',
  'data': [ 'uninitialized', 'stopped', 'check-stop', 'operating', 'load' ] }

##
# @CpuInfoS390:
#
# Additional information about a virtual S390 CPU
#
# @cpu-state: the virtual CPU's state
#
# Since: 2.12
##
{ 'struct': 'CpuInfoS390', 'data': { 'cpu-state': 'CpuS390State' } }

##
# @query-cpus:
#
# Returns a list of information about each virtual CPU.
#
# This command causes vCPU threads to exit to userspace, which causes
# a small interruption to guest CPU execution. This will have a negative
# impact on realtime guests and other latency sensitive guest workloads.
# It is recommended to use @query-cpus-fast instead of this command to
# avoid the vCPU interruption.
#
# Returns: a list of @CpuInfo for each virtual CPU
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "query-cpus" }
# <- { "return": [
#          {
#             "CPU":0,
#             "current":true,
#             "halted":false,
#             "qom_path":"/machine/unattached/device[0]",
#             "arch":"x86",
#             "pc":3227107138,
#             "thread_id":3134
#          },
#          {
#             "CPU":1,
#             "current":false,
#             "halted":true,
#             "qom_path":"/machine/unattached/device[2]",
#             "arch":"x86",
#             "pc":7108165,
#             "thread_id":3135
#          }
#       ]
#    }
#
# Notes: This interface is deprecated (since 2.12.0), and it is strongly
#        recommended that you avoid using it. Use @query-cpus-fast to
#        obtain information about virtual CPUs.
#
##
{ 'command': 'query-cpus', 'returns': ['CpuInfo'] }

##
# @CpuInfoFast:
#
# Information about a virtual CPU
#
# @cpu-index: index of the virtual CPU
#
# @qom-path: path to the CPU object in the QOM tree
#
# @thread-id: ID of the underlying host thread
#
# @props: properties describing to which node/socket/core/thread
#         virtual CPU belongs to, provided if supported by board
#
# @arch: base architecture of the cpu; deprecated since 3.0.0 in favor
#        of @target
#
# @target: the QEMU system emulation target, which determines which
#          additional fields will be listed (since 3.0)
#
# Since: 2.12
#
##
{ 'union'         : 'CpuInfoFast',
  'base'          : { 'cpu-index'    : 'int',
                      'qom-path'     : 'str',
                      'thread-id'    : 'int',
                      '*props'       : 'CpuInstanceProperties',
                      'arch'         : 'CpuInfoArch',
                      'target'       : 'SysEmuTarget' },
  'discriminator' : 'target',
  'data'          : { 's390x'        : 'CpuInfoS390' } }

##
# @query-cpus-fast:
#
# Returns information about all virtual CPUs. This command does not
# incur a performance penalty and should be used in production
# instead of query-cpus.
#
# Returns: list of @CpuInfoFast
#
# Since: 2.12
#
# Example:
#
# -> { "execute": "query-cpus-fast" }
# <- { "return": [
#         {
#             "thread-id": 25627,
#             "props": {
#                 "core-id": 0,
#                 "thread-id": 0,
#                 "socket-id": 0
#             },
#             "qom-path": "/machine/unattached/device[0]",
#             "arch":"x86",
#             "target":"x86_64",
#             "cpu-index": 0
#         },
#         {
#             "thread-id": 25628,
#             "props": {
#                 "core-id": 0,
#                 "thread-id": 0,
#                 "socket-id": 1
#             },
#             "qom-path": "/machine/unattached/device[2]",
#             "arch":"x86",
#             "target":"x86_64",
#             "cpu-index": 1
#         }
#     ]
# }
##
{ 'command': 'query-cpus-fast', 'returns': [ 'CpuInfoFast' ] }

##
# @cpu-add:
#
# Adds CPU with specified ID.
#
# @id: ID of CPU to be created, valid values [0..max_cpus)
#
# Returns: Nothing on success
#
# Since: 1.5
#
# Note: This command is deprecated.  The `device_add` command should be
#       used instead.  See the `query-hotpluggable-cpus` command for
#       details.
#
# Example:
#
# -> { "execute": "cpu-add", "arguments": { "id": 2 } }
# <- { "return": {} }
#
##
{ 'command': 'cpu-add', 'data': {'id': 'int'} }

##
# @MachineInfo:
#
# Information describing a machine.
#
# @name: the name of the machine
#
# @alias: an alias for the machine name
#
# @is-default: whether the machine is default
#
# @cpu-max: maximum number of CPUs supported by the machine type
#           (since 1.5.0)
#
# @hotpluggable-cpus: cpu hotplug via -device is supported (since 2.7.0)
#
# @numa-mem-supported: true if '-numa node,mem' option is supported by
#                      the machine type and false otherwise (since 4.1)
#
# @deprecated: if true, the machine type is deprecated and may be removed
#              in future versions of QEMU according to the QEMU deprecation
#              policy (since 4.1.0)
#
# @default-cpu-type: default CPU model typename if none is requested via
#                    the -cpu argument. (since 4.2)
#
# Since: 1.2.0
##
{ 'struct': 'MachineInfo',
  'data': { 'name': 'str', '*alias': 'str',
            '*is-default': 'bool', 'cpu-max': 'int',
            'hotpluggable-cpus': 'bool',  'numa-mem-supported': 'bool',
            'deprecated': 'bool', '*default-cpu-type': 'str' } }

##
# @query-machines:
#
# Return a list of supported machines
#
# Returns: a list of MachineInfo
#
# Since: 1.2.0
##
{ 'command': 'query-machines', 'returns': ['MachineInfo'] }

##
# @CurrentMachineParams:
#
# Information describing the running machine parameters.
#
# @wakeup-suspend-support: true if the machine supports wake up from
#                          suspend
#
# Since: 4.0
##
{ 'struct': 'CurrentMachineParams',
  'data': { 'wakeup-suspend-support': 'bool'} }

##
# @query-current-machine:
#
# Return information on the current virtual machine.
#
# Returns: CurrentMachineParams
#
# Since: 4.0
##
{ 'command': 'query-current-machine', 'returns': 'CurrentMachineParams' }

##
# @TargetInfo:
#
# Information describing the QEMU target.
#
# @arch: the target architecture
#
# Since: 1.2.0
##
{ 'struct': 'TargetInfo',
  'data': { 'arch': 'SysEmuTarget' } }

##
# @query-target:
#
# Return information about the target for this QEMU
#
# Returns: TargetInfo
#
# Since: 1.2.0
##
{ 'command': 'query-target', 'returns': 'TargetInfo' }

##
# @GuidInfo:
#
# GUID information.
#
# @guid: the globally unique identifier
#
# Since: 2.9
##
{ 'struct': 'GuidInfo', 'data': {'guid': 'str'} }

##
# @query-vm-generation-id:
#
# Show Virtual Machine Generation ID
#
# Since: 2.9
##
{ 'command': 'query-vm-generation-id', 'returns': 'GuidInfo' }

##
# @LostTickPolicy:
#
# Policy for handling lost ticks in timer devices.  Ticks end up getting
# lost when, for example, the guest is paused.
#
# @discard: throw away the missed ticks and continue with future injection
#           normally.  The guest OS will see the timer jump ahead by a
#           potentially quite significant amount all at once, as if the
#           intervening chunk of time had simply not existed; needless to
#           say, such a sudden jump can easily confuse a guest OS which is
#           not specifically prepared to deal with it.  Assuming the guest
#           OS can deal correctly with the time jump, the time in the guest
#           and in the host should now match.
#
# @delay: continue to deliver ticks at the normal rate.  The guest OS will
#         not notice anything is amiss, as from its point of view time will
#         have continued to flow normally.  The time in the guest should now
#         be behind the time in the host by exactly the amount of time during
#         which ticks have been missed.
#
# @slew: deliver ticks at a higher rate to catch up with the missed ticks.
#        The guest OS will not notice anything is amiss, as from its point
#        of view time will have continued to flow normally.  Once the timer
#        has managed to catch up with all the missing ticks, the time in
#        the guest and in the host should match.
#
# Since: 2.0
##
{ 'enum': 'LostTickPolicy',
  'data': ['discard', 'delay', 'slew' ] }

##
# @NumaOptionsType:
#
# @node: NUMA nodes configuration
#
# @dist: NUMA distance configuration (since 2.10)
#
# @cpu: property based CPU(s) to node mapping (Since: 2.10)
#
# @hmat-lb: memory latency and bandwidth information (Since: 5.0)
#
# @hmat-cache: memory side cache information (Since: 5.0)
#
# Since: 2.1
##
{ 'enum': 'NumaOptionsType',
  'data': [ 'node', 'dist', 'cpu', 'hmat-lb', 'hmat-cache' ] }

##
# @NumaOptions:
#
# A discriminated record of NUMA options. (for OptsVisitor)
#
# Since: 2.1
##
{ 'union': 'NumaOptions',
  'base': { 'type': 'NumaOptionsType' },
  'discriminator': 'type',
  'data': {
    'node': 'NumaNodeOptions',
    'dist': 'NumaDistOptions',
    'cpu': 'NumaCpuOptions',
    'hmat-lb': 'NumaHmatLBOptions',
    'hmat-cache': 'NumaHmatCacheOptions' }}

##
# @NumaNodeOptions:
#
# Create a guest NUMA node. (for OptsVisitor)
#
# @nodeid: NUMA node ID (increase by 1 from 0 if omitted)
#
# @cpus: VCPUs belonging to this node (assign VCPUS round-robin
#         if omitted)
#
# @mem: memory size of this node; mutually exclusive with @memdev.
#       Equally divide total memory among nodes if both @mem and @memdev are
#       omitted.
#
# @memdev: memory backend object.  If specified for one node,
#          it must be specified for all nodes.
#
# @initiator: defined in ACPI 6.3 Chapter 5.2.27.3 Table 5-145,
#             points to the nodeid which has the memory controller
#             responsible for this NUMA node. This field provides
#             additional information as to the initiator node that
#             is closest (as in directly attached) to this node, and
#             therefore has the best performance (since 5.0)
#
# Since: 2.1
##
{ 'struct': 'NumaNodeOptions',
  'data': {
   '*nodeid': 'uint16',
   '*cpus':   ['uint16'],
   '*mem':    'size',
   '*memdev': 'str',
   '*initiator': 'uint16' }}

##
# @NumaDistOptions:
#
# Set the distance between 2 NUMA nodes.
#
# @src: source NUMA node.
#
# @dst: destination NUMA node.
#
# @val: NUMA distance from source node to destination node.
#       When a node is unreachable from another node, set the distance
#       between them to 255.
#
# Since: 2.10
##
{ 'struct': 'NumaDistOptions',
  'data': {
   'src': 'uint16',
   'dst': 'uint16',
   'val': 'uint8' }}

##
# @NumaCpuOptions:
#
# Option "-numa cpu" overrides default cpu to node mapping.
# It accepts the same set of cpu properties as returned by
# query-hotpluggable-cpus[].props, where node-id could be used to
# override default node mapping.
#
# Since: 2.10
##
{ 'struct': 'NumaCpuOptions',
   'base': 'CpuInstanceProperties',
   'data' : {} }

##
# @HmatLBMemoryHierarchy:
#
# The memory hierarchy in the System Locality Latency and Bandwidth
# Information Structure of HMAT (Heterogeneous Memory Attribute Table)
#
# For more information about @HmatLBMemoryHierarchy, see chapter
# 5.2.27.4: Table 5-146: Field "Flags" of ACPI 6.3 spec.
#
# @memory: the structure represents the memory performance
#
# @first-level: first level of memory side cache
#
# @second-level: second level of memory side cache
#
# @third-level: third level of memory side cache
#
# Since: 5.0
##
{ 'enum': 'HmatLBMemoryHierarchy',
  'data': [ 'memory', 'first-level', 'second-level', 'third-level' ] }

##
# @HmatLBDataType:
#
# Data type in the System Locality Latency and Bandwidth
# Information Structure of HMAT (Heterogeneous Memory Attribute Table)
#
# For more information about @HmatLBDataType, see chapter
# 5.2.27.4: Table 5-146:  Field "Data Type" of ACPI 6.3 spec.
#
# @access-latency: access latency (nanoseconds)
#
# @read-latency: read latency (nanoseconds)
#
# @write-latency: write latency (nanoseconds)
#
# @access-bandwidth: access bandwidth (Bytes per second)
#
# @read-bandwidth: read bandwidth (Bytes per second)
#
# @write-bandwidth: write bandwidth (Bytes per second)
#
# Since: 5.0
##
{ 'enum': 'HmatLBDataType',
  'data': [ 'access-latency', 'read-latency', 'write-latency',
            'access-bandwidth', 'read-bandwidth', 'write-bandwidth' ] }

##
# @NumaHmatLBOptions:
#
# Set the system locality latency and bandwidth information
# between Initiator and Target proximity Domains.
#
# For more information about @NumaHmatLBOptions, see chapter
# 5.2.27.4: Table 5-146 of ACPI 6.3 spec.
#
# @initiator: the Initiator Proximity Domain.
#
# @target: the Target Proximity Domain.
#
# @hierarchy: the Memory Hierarchy. Indicates the performance
#             of memory or side cache.
#
# @data-type: presents the type of data, access/read/write
#             latency or hit latency.
#
# @latency: the value of latency from @initiator to @target
#           proximity domain, the latency unit is "ns(nanosecond)".
#
# @bandwidth: the value of bandwidth between @initiator and @target
#             proximity domain, the bandwidth unit is
#             "Bytes per second".
#
# Since: 5.0
##
{ 'struct': 'NumaHmatLBOptions',
    'data': {
    'initiator': 'uint16',
    'target': 'uint16',
    'hierarchy': 'HmatLBMemoryHierarchy',
    'data-type': 'HmatLBDataType',
    '*latency': 'uint64',
    '*bandwidth': 'size' }}

##
# @HmatCacheAssociativity:
#
# Cache associativity in the Memory Side Cache Information Structure
# of HMAT
#
# For more information of @HmatCacheAssociativity, see chapter
# 5.2.27.5: Table 5-147 of ACPI 6.3 spec.
#
# @none: None (no memory side cache in this proximity domain,
#              or cache associativity unknown)
#
# @direct: Direct Mapped
#
# @complex: Complex Cache Indexing (implementation specific)
#
# Since: 5.0
##
{ 'enum': 'HmatCacheAssociativity',
  'data': [ 'none', 'direct', 'complex' ] }

##
# @HmatCacheWritePolicy:
#
# Cache write policy in the Memory Side Cache Information Structure
# of HMAT
#
# For more information of @HmatCacheWritePolicy, see chapter
# 5.2.27.5: Table 5-147: Field "Cache Attributes" of ACPI 6.3 spec.
#
# @none: None (no memory side cache in this proximity domain,
#        or cache write policy unknown)
#
# @write-back: Write Back (WB)
#
# @write-through: Write Through (WT)
#
# Since: 5.0
##
{ 'enum': 'HmatCacheWritePolicy',
  'data': [ 'none', 'write-back', 'write-through' ] }

##
# @NumaHmatCacheOptions:
#
# Set the memory side cache information for a given memory domain.
#
# For more information of @NumaHmatCacheOptions, see chapter
# 5.2.27.5: Table 5-147: Field "Cache Attributes" of ACPI 6.3 spec.
#
# @node-id: the memory proximity domain to which the memory belongs.
#
# @size: the size of memory side cache in bytes.
#
# @level: the cache level described in this structure.
#
# @associativity: the cache associativity,
#                 none/direct-mapped/complex(complex cache indexing).
#
# @policy: the write policy, none/write-back/write-through.
#
# @line: the cache Line size in bytes.
#
# Since: 5.0
##
{ 'struct': 'NumaHmatCacheOptions',
  'data': {
   'node-id': 'uint32',
   'size': 'size',
   'level': 'uint8',
   'associativity': 'HmatCacheAssociativity',
   'policy': 'HmatCacheWritePolicy',
   'line': 'uint16' }}

##
# @HostMemPolicy:
#
# Host memory policy types
#
# @default: restore default policy, remove any nondefault policy
#
# @preferred: set the preferred host nodes for allocation
#
# @bind: a strict policy that restricts memory allocation to the
#        host nodes specified
#
# @interleave: memory allocations are interleaved across the set
#              of host nodes specified
#
# Since: 2.1
##
{ 'enum': 'HostMemPolicy',
  'data': [ 'default', 'preferred', 'bind', 'interleave' ] }

##
# @Memdev:
#
# Information about memory backend
#
# @id: backend's ID if backend has 'id' property (since 2.9)
#
# @size: memory backend size
#
# @merge: enables or disables memory merge support
#
# @dump: includes memory backend's memory in a core dump or not
#
# @prealloc: enables or disables memory preallocation
#
# @host-nodes: host nodes for its memory policy
#
# @policy: memory policy of memory backend
#
# Since: 2.1
##
{ 'struct': 'Memdev',
  'data': {
    '*id':        'str',
    'size':       'size',
    'merge':      'bool',
    'dump':       'bool',
    'prealloc':   'bool',
    'host-nodes': ['uint16'],
    'policy':     'HostMemPolicy' }}

##
# @query-memdev:
#
# Returns information for all memory backends.
#
# Returns: a list of @Memdev.
#
# Since: 2.1
#
# Example:
#
# -> { "execute": "query-memdev" }
# <- { "return": [
#        {
#          "id": "mem1",
#          "size": 536870912,
#          "merge": false,
#          "dump": true,
#          "prealloc": false,
#          "host-nodes": [0, 1],
#          "policy": "bind"
#        },
#        {
#          "size": 536870912,
#          "merge": false,
#          "dump": true,
#          "prealloc": true,
#          "host-nodes": [2, 3],
#          "policy": "preferred"
#        }
#      ]
#    }
#
##
{ 'command': 'query-memdev', 'returns': ['Memdev'], 'allow-preconfig': true }

##
# @CpuInstanceProperties:
#
# List of properties to be used for hotplugging a CPU instance,
# it should be passed by management with device_add command when
# a CPU is being hotplugged.
#
# @node-id: NUMA node ID the CPU belongs to
# @socket-id: socket number within node/board the CPU belongs to
# @die-id: die number within node/board the CPU belongs to (Since 4.1)
# @core-id: core number within die the CPU belongs to# @thread-id: thread number within core the CPU belongs to
#
# Note: currently there are 5 properties that could be present
#       but management should be prepared to pass through other
#       properties with device_add command to allow for future
#       interface extension. This also requires the filed names to be kept in
#       sync with the properties passed to -device/device_add.
#
# Since: 2.7
##
{ 'struct': 'CpuInstanceProperties',
  'data': { '*node-id': 'int',
            '*socket-id': 'int',
            '*die-id': 'int',
            '*core-id': 'int',
            '*thread-id': 'int'
  }
}

##
# @HotpluggableCPU:
#
# @type: CPU object type for usage with device_add command
# @props: list of properties to be used for hotplugging CPU
# @vcpus-count: number of logical VCPU threads @HotpluggableCPU provides
# @qom-path: link to existing CPU object if CPU is present or
#            omitted if CPU is not present.
#
# Since: 2.7
##
{ 'struct': 'HotpluggableCPU',
  'data': { 'type': 'str',
            'vcpus-count': 'int',
            'props': 'CpuInstanceProperties',
            '*qom-path': 'str'
          }
}

##
# @query-hotpluggable-cpus:
#
# TODO: Better documentation; currently there is none.
#
# Returns: a list of HotpluggableCPU objects.
#
# Since: 2.7
#
# Example:
#
# For pseries machine type started with -smp 2,cores=2,maxcpus=4 -cpu POWER8:
#
# -> { "execute": "query-hotpluggable-cpus" }
# <- {"return": [
#      { "props": { "core": 8 }, "type": "POWER8-spapr-cpu-core",
#        "vcpus-count": 1 },
#      { "props": { "core": 0 }, "type": "POWER8-spapr-cpu-core",
#        "vcpus-count": 1, "qom-path": "/machine/unattached/device[0]"}
#    ]}'
#
# For pc machine type started with -smp 1,maxcpus=2:
#
# -> { "execute": "query-hotpluggable-cpus" }
# <- {"return": [
#      {
#         "type": "qemu64-x86_64-cpu", "vcpus-count": 1,
#         "props": {"core-id": 0, "socket-id": 1, "thread-id": 0}
#      },
#      {
#         "qom-path": "/machine/unattached/device[0]",
#         "type": "qemu64-x86_64-cpu", "vcpus-count": 1,
#         "props": {"core-id": 0, "socket-id": 0, "thread-id": 0}
#      }
#    ]}
#
# For s390x-virtio-ccw machine type started with -smp 1,maxcpus=2 -cpu qemu
# (Since: 2.11):
#
# -> { "execute": "query-hotpluggable-cpus" }
# <- {"return": [
#      {
#         "type": "qemu-s390x-cpu", "vcpus-count": 1,
#         "props": { "core-id": 1 }
#      },
#      {
#         "qom-path": "/machine/unattached/device[0]",
#         "type": "qemu-s390x-cpu", "vcpus-count": 1,
#         "props": { "core-id": 0 }
#      }
#    ]}
#
##
{ 'command': 'query-hotpluggable-cpus', 'returns': ['HotpluggableCPU'],
             'allow-preconfig': true }

##
# @set-numa-node:
#
# Runtime equivalent of '-numa' CLI option, available at
# preconfigure stage to configure numa mapping before initializing
# machine.
#
# Since 3.0
##
{ 'command': 'set-numa-node', 'boxed': true,
  'data': 'NumaOptions',
  'allow-preconfig': true
}

##
# @balloon:
#
# Request the balloon driver to change its balloon size.
#
# @value: the target size of the balloon in bytes
#
# Returns: - Nothing on success
#          - If the balloon driver is enabled but not functional because the KVM
#            kernel module cannot support it, KvmMissingCap
#          - If no balloon device is present, DeviceNotActive
#
# Notes: This command just issues a request to the guest.  When it returns,
#        the balloon size may not have changed.  A guest can change the balloon
#        size independent of this command.
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "balloon", "arguments": { "value": 536870912 } }
# <- { "return": {} }
#
##
{ 'command': 'balloon', 'data': {'value': 'int'} }

##
# @BalloonInfo:
#
# Information about the guest balloon device.
#
# @actual: the number of bytes the balloon currently contains
#
# Since: 0.14.0
#
##
{ 'struct': 'BalloonInfo', 'data': {'actual': 'int' } }

##
# @query-balloon:
#
# Return information about the balloon device.
#
# Returns: - @BalloonInfo on success
#          - If the balloon driver is enabled but not functional because the KVM
#            kernel module cannot support it, KvmMissingCap
#          - If no balloon device is present, DeviceNotActive
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "query-balloon" }
# <- { "return": {
#          "actual": 1073741824,
#       }
#    }
#
##
{ 'command': 'query-balloon', 'returns': 'BalloonInfo' }

##
# @BALLOON_CHANGE:
#
# Emitted when the guest changes the actual BALLOON level. This value is
# equivalent to the @actual field return by the 'query-balloon' command
#
# @actual: actual level of the guest memory balloon in bytes
#
# Note: this event is rate-limited.
#
# Since: 1.2
#
# Example:
#
# <- { "event": "BALLOON_CHANGE",
#      "data": { "actual": 944766976 },
#      "timestamp": { "seconds": 1267020223, "microseconds": 435656 } }
#
##
{ 'event': 'BALLOON_CHANGE',
  'data': { 'actual': 'int' } }

##
# @AcpiTableOptions:
#
# Specify an ACPI table on the command line to load.
#
# At most one of @file and @data can be specified. The list of files specified
# by any one of them is loaded and concatenated in order. If both are omitted,
# @data is implied.
#
# Other fields / optargs can be used to override fields of the generic ACPI
# table header; refer to the ACPI specification 5.0, section 5.2.6 System
# Description Table Header. If a header field is not overridden, then the
# corresponding value from the concatenated blob is used (in case of @file), or
# it is filled in with a hard-coded value (in case of @data).
#
# String fields are copied into the matching ACPI member from lowest address
# upwards, and silently truncated / NUL-padded to length.
#
# @sig: table signature / identifier (4 bytes)
#
# @rev: table revision number (dependent on signature, 1 byte)
#
# @oem_id: OEM identifier (6 bytes)
#
# @oem_table_id: OEM table identifier (8 bytes)
#
# @oem_rev: OEM-supplied revision number (4 bytes)
#
# @asl_compiler_id: identifier of the utility that created the table
#                   (4 bytes)
#
# @asl_compiler_rev: revision number of the utility that created the
#                    table (4 bytes)
#
# @file: colon (:) separated list of pathnames to load and
#        concatenate as table data. The resultant binary blob is expected to
#        have an ACPI table header. At least one file is required. This field
#        excludes @data.
#
# @data: colon (:) separated list of pathnames to load and
#        concatenate as table data. The resultant binary blob must not have an
#        ACPI table header. At least one file is required. This field excludes
#        @file.
#
# Since: 1.5
##
{ 'struct': 'AcpiTableOptions',
  'data': {
    '*sig':               'str',
    '*rev':               'uint8',
    '*oem_id':            'str',
    '*oem_table_id':      'str',
    '*oem_rev':           'uint32',
    '*asl_compiler_id':   'str',
    '*asl_compiler_rev':  'uint32',
    '*file':              'str',
    '*data':              'str' }}

##
# @MEM_UNPLUG_ERROR:
#
# Emitted when memory hot unplug error occurs.
#
# @device: device name
#
# @msg: Informative message
#
# Since: 2.4
#
# Example:
#
# <- { "event": "MEM_UNPLUG_ERROR"
#      "data": { "device": "dimm1",
#                "msg": "acpi: device unplug for unsupported device"
#      },
#      "timestamp": { "seconds": 1265044230, "microseconds": 450486 } }
#
##
{ 'event': 'MEM_UNPLUG_ERROR',
  'data': { 'device': 'str', 'msg': 'str' } }

##
# @ACPISlotType:
#
# @DIMM: memory slot
# @CPU: logical CPU slot (since 2.7)
##
{ 'enum': 'ACPISlotType', 'data': [ 'DIMM', 'CPU' ] }

##
# @ACPIOSTInfo:
#
# OSPM Status Indication for a device
# For description of possible values of @source and @status fields
# see "_OST (OSPM Status Indication)" chapter of ACPI5.0 spec.
#
# @device: device ID associated with slot
#
# @slot: slot ID, unique per slot of a given @slot-type
#
# @slot-type: type of the slot
#
# @source: an integer containing the source event
#
# @status: an integer containing the status code
#
# Since: 2.1
##
{ 'struct': 'ACPIOSTInfo',
  'data'  : { '*device': 'str',
              'slot': 'str',
              'slot-type': 'ACPISlotType',
              'source': 'int',
              'status': 'int' } }

##
# @query-acpi-ospm-status:
#
# Return a list of ACPIOSTInfo for devices that support status
# reporting via ACPI _OST method.
#
# Since: 2.1
#
# Example:
#
# -> { "execute": "query-acpi-ospm-status" }
# <- { "return": [ { "device": "d1", "slot": "0", "slot-type": "DIMM", "source": 1, "status": 0},
#                  { "slot": "1", "slot-type": "DIMM", "source": 0, "status": 0},
#                  { "slot": "2", "slot-type": "DIMM", "source": 0, "status": 0},
#                  { "slot": "3", "slot-type": "DIMM", "source": 0, "status": 0}
#    ]}
#
##
{ 'command': 'query-acpi-ospm-status', 'returns': ['ACPIOSTInfo'] }

##
# @ACPI_DEVICE_OST:
#
# Emitted when guest executes ACPI _OST method.
#
# @info: OSPM Status Indication
#
# Since: 2.1
#
# Example:
#
# <- { "event": "ACPI_DEVICE_OST",
#      "data": { "device": "d1", "slot": "0",
#                "slot-type": "DIMM", "source": 1, "status": 0 } }
#
##
{ 'event': 'ACPI_DEVICE_OST',
     'data': { 'info': 'ACPIOSTInfo' } }

##
# @PciMemoryRange:
#
# A PCI device memory region
#
# @base: the starting address (guest physical)
#
# @limit: the ending address (guest physical)
#
# Since: 0.14.0
##
{ 'struct': 'PciMemoryRange', 'data': {'base': 'int', 'limit': 'int'} }

##
# @PciMemoryRegion:
#
# Information about a PCI device I/O region.
#
# @bar: the index of the Base Address Register for this region
#
# @type: - 'io' if the region is a PIO region
#        - 'memory' if the region is a MMIO region
#
# @size: memory size
#
# @prefetch: if @type is 'memory', true if the memory is prefetchable
#
# @mem_type_64: if @type is 'memory', true if the BAR is 64-bit
#
# Since: 0.14.0
##
{ 'struct': 'PciMemoryRegion',
  'data': {'bar': 'int', 'type': 'str', 'address': 'int', 'size': 'int',
           '*prefetch': 'bool', '*mem_type_64': 'bool' } }

##
# @PciBusInfo:
#
# Information about a bus of a PCI Bridge device
#
# @number: primary bus interface number.  This should be the number of the
#          bus the device resides on.
#
# @secondary: secondary bus interface number.  This is the number of the
#             main bus for the bridge
#
# @subordinate: This is the highest number bus that resides below the
#               bridge.
#
# @io_range: The PIO range for all devices on this bridge
#
# @memory_range: The MMIO range for all devices on this bridge
#
# @prefetchable_range: The range of prefetchable MMIO for all devices on
#                      this bridge
#
# Since: 2.4
##
{ 'struct': 'PciBusInfo',
  'data': {'number': 'int', 'secondary': 'int', 'subordinate': 'int',
           'io_range': 'PciMemoryRange',
           'memory_range': 'PciMemoryRange',
           'prefetchable_range': 'PciMemoryRange' } }

##
# @PciBridgeInfo:
#
# Information about a PCI Bridge device
#
# @bus: information about the bus the device resides on
#
# @devices: a list of @PciDeviceInfo for each device on this bridge
#
# Since: 0.14.0
##
{ 'struct': 'PciBridgeInfo',
  'data': {'bus': 'PciBusInfo', '*devices': ['PciDeviceInfo']} }

##
# @PciDeviceClass:
#
# Information about the Class of a PCI device
#
# @desc: a string description of the device's class
#
# @class: the class code of the device
#
# Since: 2.4
##
{ 'struct': 'PciDeviceClass',
  'data': {'*desc': 'str', 'class': 'int'} }

##
# @PciDeviceId:
#
# Information about the Id of a PCI device
#
# @device: the PCI device id
#
# @vendor: the PCI vendor id
#
# @subsystem: the PCI subsystem id (since 3.1)
#
# @subsystem-vendor: the PCI subsystem vendor id (since 3.1)
#
# Since: 2.4
##
{ 'struct': 'PciDeviceId',
  'data': {'device': 'int', 'vendor': 'int', '*subsystem': 'int',
            '*subsystem-vendor': 'int'} }

##
# @PciDeviceInfo:
#
# Information about a PCI device
#
# @bus: the bus number of the device
#
# @slot: the slot the device is located in
#
# @function: the function of the slot used by the device
#
# @class_info: the class of the device
#
# @id: the PCI device id
#
# @irq: if an IRQ is assigned to the device, the IRQ number
#
# @qdev_id: the device name of the PCI device
#
# @pci_bridge: if the device is a PCI bridge, the bridge information
#
# @regions: a list of the PCI I/O regions associated with the device
#
# Notes: the contents of @class_info.desc are not stable and should only be
#        treated as informational.
#
# Since: 0.14.0
##
{ 'struct': 'PciDeviceInfo',
  'data': {'bus': 'int', 'slot': 'int', 'function': 'int',
           'class_info': 'PciDeviceClass', 'id': 'PciDeviceId',
           '*irq': 'int', 'qdev_id': 'str', '*pci_bridge': 'PciBridgeInfo',
           'regions': ['PciMemoryRegion']} }

##
# @PciInfo:
#
# Information about a PCI bus
#
# @bus: the bus index
#
# @devices: a list of devices on this bus
#
# Since: 0.14.0
##
{ 'struct': 'PciInfo', 'data': {'bus': 'int', 'devices': ['PciDeviceInfo']} }

##
# @query-pci:
#
# Return information about the PCI bus topology of the guest.
#
# Returns: a list of @PciInfo for each PCI bus. Each bus is
#          represented by a json-object, which has a key with a json-array of
#          all PCI devices attached to it. Each device is represented by a
#          json-object.
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "query-pci" }
# <- { "return": [
#          {
#             "bus": 0,
#             "devices": [
#                {
#                   "bus": 0,
#                   "qdev_id": "",
#                   "slot": 0,
#                   "class_info": {
#                      "class": 1536,
#                      "desc": "Host bridge"
#                   },
#                   "id": {
#                      "device": 32902,
#                      "vendor": 4663
#                   },
#                   "function": 0,
#                   "regions": [
#                   ]
#                },
#                {
#                   "bus": 0,
#                   "qdev_id": "",
#                   "slot": 1,
#                   "class_info": {
#                      "class": 1537,
#                      "desc": "ISA bridge"
#                   },
#                   "id": {
#                      "device": 32902,
#                      "vendor": 28672
#                   },
#                   "function": 0,
#                   "regions": [
#                   ]
#                },
#                {
#                   "bus": 0,
#                   "qdev_id": "",
#                   "slot": 1,
#                   "class_info": {
#                      "class": 257,
#                      "desc": "IDE controller"
#                   },
#                   "id": {
#                      "device": 32902,
#                      "vendor": 28688
#                   },
#                   "function": 1,
#                   "regions": [
#                      {
#                         "bar": 4,
#                         "size": 16,
#                         "address": 49152,
#                         "type": "io"
#                      }
#                   ]
#                },
#                {
#                   "bus": 0,
#                   "qdev_id": "",
#                   "slot": 2,
#                   "class_info": {
#                      "class": 768,
#                      "desc": "VGA controller"
#                   },
#                   "id": {
#                      "device": 4115,
#                      "vendor": 184
#                   },
#                   "function": 0,
#                   "regions": [
#                      {
#                         "prefetch": true,
#                         "mem_type_64": false,
#                         "bar": 0,
#                         "size": 33554432,
#                         "address": 4026531840,
#                         "type": "memory"
#                      },
#                      {
#                         "prefetch": false,
#                         "mem_type_64": false,
#                         "bar": 1,
#                         "size": 4096,
#                         "address": 4060086272,
#                         "type": "memory"
#                      },
#                      {
#                         "prefetch": false,
#                         "mem_type_64": false,
#                         "bar": 6,
#                         "size": 65536,
#                         "address": -1,
#                         "type": "memory"
#                      }
#                   ]
#                },
#                {
#                   "bus": 0,
#                   "qdev_id": "",
#                   "irq": 11,
#                   "slot": 4,
#                   "class_info": {
#                      "class": 1280,
#                      "desc": "RAM controller"
#                   },
#                   "id": {
#                      "device": 6900,
#                      "vendor": 4098
#                   },
#                   "function": 0,
#                   "regions": [
#                      {
#                         "bar": 0,
#                         "size": 32,
#                         "address": 49280,
#                         "type": "io"
#                      }
#                   ]
#                }
#             ]
#          }
#       ]
#    }
#
# Note: This example has been shortened as the real response is too long.
#
##
{ 'command': 'query-pci', 'returns': ['PciInfo'] }

##
# @MemoryInfo:
#
# Actual memory information in bytes.
#
# @base-memory: size of "base" memory specified with command line
#               option -m.
#
# @plugged-memory: size of memory that can be hot-unplugged. This field
#                  is omitted if target doesn't support memory hotplug
#                  (i.e. CONFIG_MEM_DEVICE not defined at build time).
#
# Since: 2.11.0
##
{ 'struct': 'MemoryInfo',
  'data'  : { 'base-memory': 'size', '*plugged-memory': 'size' } }

##
# @query-memory-size-summary:
#
# Return the amount of initially allocated and present hotpluggable (if
# enabled) memory in bytes.
#
# Example:
#
# -> { "execute": "query-memory-size-summary" }
# <- { "return": { "base-memory": 4294967296, "plugged-memory": 0 } }
#
# Since: 2.11.0
##
{ 'command': 'query-memory-size-summary', 'returns': 'MemoryInfo' }

##
# @PCDIMMDeviceInfo:
#
# PCDIMMDevice state information
#
# @id: device's ID
#
# @addr: physical address, where device is mapped
#
# @size: size of memory that the device provides
#
# @slot: slot number at which device is plugged in
#
# @node: NUMA node number where device is plugged in
#
# @memdev: memory backend linked with device
#
# @hotplugged: true if device was hotplugged
#
# @hotpluggable: true if device if could be added/removed while machine is running
#
# Since: 2.1
##
{ 'struct': 'PCDIMMDeviceInfo',
  'data': { '*id': 'str',
            'addr': 'int',
            'size': 'int',
            'slot': 'int',
            'node': 'int',
            'memdev': 'str',
            'hotplugged': 'bool',
            'hotpluggable': 'bool'
          }
}

##
# @VirtioPMEMDeviceInfo:
#
# VirtioPMEM state information
#
# @id: device's ID
#
# @memaddr: physical address in memory, where device is mapped
#
# @size: size of memory that the device provides
#
# @memdev: memory backend linked with device
#
# Since: 4.1
##
{ 'struct': 'VirtioPMEMDeviceInfo',
  'data': { '*id': 'str',
            'memaddr': 'size',
            'size': 'size',
            'memdev': 'str'
          }
}

##
# @MemoryDeviceInfo:
#
# Union containing information about a memory device
#
# nvdimm is included since 2.12. virtio-pmem is included since 4.1.
#
# Since: 2.1
##
{ 'union': 'MemoryDeviceInfo',
  'data': { 'dimm': 'PCDIMMDeviceInfo',
            'nvdimm': 'PCDIMMDeviceInfo',
            'virtio-pmem': 'VirtioPMEMDeviceInfo'
          }
}

##
# @query-memory-devices:
#
# Lists available memory devices and their state
#
# Since: 2.1
#
# Example:
#
# -> { "execute": "query-memory-devices" }
# <- { "return": [ { "data":
#                       { "addr": 5368709120,
#                         "hotpluggable": true,
#                         "hotplugged": true,
#                         "id": "d1",
#                         "memdev": "/objects/memX",
#                         "node": 0,
#                         "size": 1073741824,
#                         "slot": 0},
#                    "type": "dimm"
#                  } ] }
#
##
{ 'command': 'query-memory-devices', 'returns': ['MemoryDeviceInfo'] }
